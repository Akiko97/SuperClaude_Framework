import { EventEmitter } from 'eventemitter3';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '@superclaude/shared';
import {
  WorkflowEvent,
  CoordinationStrategy,
  CoordinationError
} from '../types/index.js';

/**
 * Coordinates workflow events and cross-component communication
 * Implements event-driven architecture for system coordination
 */
export class WorkflowCoordinator extends EventEmitter {
  private eventQueue: WorkflowEvent[];
  private strategies: Map<string, CoordinationStrategy>;
  private eventHandlers: Map<string, EventHandler[]>;
  private isProcessing: boolean;
  private processingInterval: NodeJS.Timeout | null;

  constructor() {
    super();
    this.eventQueue = [];
    this.strategies = new Map();
    this.eventHandlers = new Map();
    this.isProcessing = false;
    this.processingInterval = null;
    
    this.startEventProcessing();
  }

  /**
   * Start event processing loop
   */
  private startEventProcessing(): void {
    this.processingInterval = setInterval(async () => {
      if (!this.isProcessing && this.eventQueue.length > 0) {
        await this.processEventQueue();
      }
    }, 100); // Process every 100ms
  }

  /**\n   * Process workflow event\n   */\n  async processEvent(event: WorkflowEvent): Promise<void> {\n    try {\n      logger.debug('Processing workflow event', {\n        eventId: event.id,\n        type: event.type,\n        source: event.source\n      });\n      \n      // Add to queue\n      this.eventQueue.push(event);\n      \n      // Sort by priority (higher priority first)\n      this.eventQueue.sort((a, b) => b.priority - a.priority);\n      \n      // Emit event for external listeners\n      this.emit('event-processed', event);\n      \n    } catch (error) {\n      logger.error('Error processing workflow event', {\n        eventId: event.id,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw new CoordinationError(\n        `Failed to process workflow event: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        { eventId: event.id }\n      );\n    }\n  }\n\n  /**\n   * Process event queue\n   */\n  private async processEventQueue(): Promise<void> {\n    if (this.isProcessing || this.eventQueue.length === 0) {\n      return;\n    }\n    \n    this.isProcessing = true;\n    \n    try {\n      const event = this.eventQueue.shift();\n      if (!event) {\n        return;\n      }\n      \n      logger.debug('Processing queued event', {\n        eventId: event.id,\n        type: event.type,\n        queueLength: this.eventQueue.length\n      });\n      \n      // Apply coordination strategies\n      await this.applyCoordinationStrategies(event);\n      \n      // Execute event handlers\n      await this.executeEventHandlers(event);\n      \n      // Route event to target if specified\n      if (event.target) {\n        await this.routeEventToTarget(event);\n      }\n      \n    } catch (error) {\n      logger.error('Error in event queue processing', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  /**\n   * Apply coordination strategies to event\n   */\n  private async applyCoordinationStrategies(event: WorkflowEvent): Promise<void> {\n    for (const [strategyName, strategy] of this.strategies.entries()) {\n      try {\n        // Check if strategy has matching triggers\n        const matchingTriggers = strategy.triggers.filter(trigger => \n          trigger.event === event.type\n        );\n        \n        if (matchingTriggers.length === 0) {\n          continue;\n        }\n        \n        logger.debug('Applying coordination strategy', {\n          strategy: strategyName,\n          eventType: event.type,\n          triggerCount: matchingTriggers.length\n        });\n        \n        // Apply strategy rules\n        for (const rule of strategy.rules) {\n          if (!rule.enabled) {\n            continue;\n          }\n          \n          // Evaluate rule condition\n          const conditionMet = await this.evaluateRuleCondition(rule.condition, event);\n          \n          if (conditionMet) {\n            logger.info('Coordination rule triggered', {\n              strategy: strategyName,\n              rule: rule.condition,\n              action: rule.action\n            });\n            \n            // Execute rule action\n            await this.executeRuleAction(rule.action, event);\n          }\n        }\n        \n        // Execute triggers\n        for (const trigger of matchingTriggers) {\n          if (trigger.async) {\n            // Execute asynchronously\n            setImmediate(() => this.executeTriggerHandler(trigger.handler, event));\n          } else {\n            // Execute synchronously\n            await this.executeTriggerHandler(trigger.handler, event);\n          }\n        }\n        \n      } catch (error) {\n        logger.error('Error applying coordination strategy', {\n          strategy: strategyName,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n        // Continue with other strategies\n      }\n    }\n  }\n\n  /**\n   * Execute event handlers\n   */\n  private async executeEventHandlers(event: WorkflowEvent): Promise<void> {\n    const handlers = this.eventHandlers.get(event.type) || [];\n    \n    if (handlers.length === 0) {\n      return;\n    }\n    \n    logger.debug('Executing event handlers', {\n      eventType: event.type,\n      handlerCount: handlers.length\n    });\n    \n    for (const handler of handlers) {\n      try {\n        await handler.execute(event);\n      } catch (error) {\n        logger.error('Event handler execution failed', {\n          handlerName: handler.name,\n          eventType: event.type,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n        // Continue with other handlers\n      }\n    }\n  }\n\n  /**\n   * Route event to target component\n   */\n  private async routeEventToTarget(event: WorkflowEvent): Promise<void> {\n    if (!event.target) {\n      return;\n    }\n    \n    logger.debug('Routing event to target', {\n      eventId: event.id,\n      target: event.target\n    });\n    \n    // Emit targeted event\n    this.emit(`target:${event.target}`, event);\n  }\n\n  /**\n   * Evaluate rule condition\n   */\n  private async evaluateRuleCondition(condition: string, event: WorkflowEvent): Promise<boolean> {\n    try {\n      // Simple condition evaluation (would be more sophisticated in production)\n      const context = {\n        event,\n        complexity: this.extractComplexity(event),\n        tokenUsage: this.extractTokenUsage(event),\n        operationType: this.extractOperationType(event),\n        fileCount: this.extractFileCount(event)\n      };\n      \n      // Parse and evaluate condition\n      return this.evaluateConditionExpression(condition, context);\n      \n    } catch (error) {\n      logger.warn('Error evaluating rule condition', {\n        condition,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate condition expression\n   */\n  private evaluateConditionExpression(condition: string, context: any): boolean {\n    // Simple expression evaluator (production would use a proper parser)\n    try {\n      // Replace variables with values\n      let expression = condition;\n      \n      // Handle complexity conditions\n      if (expression.includes('complexity')) {\n        expression = expression.replace('complexity', context.complexity.toString());\n      }\n      \n      // Handle token usage conditions\n      if (expression.includes('token-usage')) {\n        const tokenUsagePercent = context.tokenUsage / 100000; // Assume 100k max\n        expression = expression.replace('token-usage', tokenUsagePercent.toString());\n      }\n      \n      // Handle operation type conditions\n      if (expression.includes('operation-type')) {\n        const operationType = `\"${context.operationType}\"`;\n        expression = expression.replace('operation-type', operationType);\n      }\n      \n      // Handle file count conditions\n      if (expression.includes('file-count')) {\n        expression = expression.replace('file-count', context.fileCount.toString());\n      }\n      \n      // Simple evaluation (production would use safe evaluator)\n      return eval(expression);\n      \n    } catch (error) {\n      logger.warn('Error evaluating expression', {\n        condition,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Execute rule action\n   */\n  private async executeRuleAction(action: string, event: WorkflowEvent): Promise<void> {\n    logger.info('Executing rule action', { action, eventType: event.type });\n    \n    switch (action) {\n      case 'enable-wave-mode':\n        await this.enableWaveMode(event);\n        break;\n      case 'enable-compression':\n        await this.enableCompression(event);\n        break;\n      case 'enable-deep-analysis':\n        await this.enableDeepAnalysis(event);\n        break;\n      case 'enable-parallel-processing':\n        await this.enableParallelProcessing(event);\n        break;\n      case 'enable-distributed-processing':\n        await this.enableDistributedProcessing(event);\n        break;\n      case 'enable-validation-gates':\n        await this.enableValidationGates(event);\n        break;\n      default:\n        logger.warn('Unknown rule action', { action });\n    }\n  }\n\n  /**\n   * Execute trigger handler\n   */\n  private async executeTriggerHandler(handlerName: string, event: WorkflowEvent): Promise<void> {\n    logger.debug('Executing trigger handler', { handlerName, eventType: event.type });\n    \n    switch (handlerName) {\n      case 'evaluate-coordination-need':\n        await this.evaluateCoordinationNeed(event);\n        break;\n      case 'aggregate-responses':\n        await this.aggregateResponses(event);\n        break;\n      case 'create-analysis-plan':\n        await this.createAnalysisPlan(event);\n        break;\n      case 'create-enterprise-plan':\n        await this.createEnterprisePlan(event);\n        break;\n      default:\n        logger.warn('Unknown trigger handler', { handlerName });\n    }\n  }\n\n  // ==================== CONTEXT EXTRACTORS ====================\n\n  private extractComplexity(event: WorkflowEvent): number {\n    return event.payload.complexity || 0.5;\n  }\n\n  private extractTokenUsage(event: WorkflowEvent): number {\n    return event.payload.tokenUsage || 0;\n  }\n\n  private extractOperationType(event: WorkflowEvent): string {\n    return event.payload.operationType || 'unknown';\n  }\n\n  private extractFileCount(event: WorkflowEvent): number {\n    return event.payload.fileCount || 0;\n  }\n\n  // ==================== ACTION HANDLERS ====================\n\n  private async enableWaveMode(event: WorkflowEvent): Promise<void> {\n    logger.info('Wave mode enabled by coordination rule', { eventId: event.id });\n    \n    // Create wave enable event\n    const waveEvent: WorkflowEvent = {\n      id: uuidv4(),\n      type: 'wave-enabled',\n      source: 'workflow-coordinator',\n      target: event.source,\n      payload: { originalEvent: event.id, reason: 'complexity-threshold' },\n      timestamp: new Date(),\n      priority: 8\n    };\n    \n    await this.processEvent(waveEvent);\n  }\n\n  private async enableCompression(event: WorkflowEvent): Promise<void> {\n    logger.info('Compression enabled by coordination rule', { eventId: event.id });\n    \n    const compressionEvent: WorkflowEvent = {\n      id: uuidv4(),\n      type: 'compression-enabled',\n      source: 'workflow-coordinator',\n      target: event.source,\n      payload: { originalEvent: event.id, reason: 'token-usage-threshold' },\n      timestamp: new Date(),\n      priority: 7\n    };\n    \n    await this.processEvent(compressionEvent);\n  }\n\n  private async enableDeepAnalysis(event: WorkflowEvent): Promise<void> {\n    logger.info('Deep analysis enabled by coordination rule', { eventId: event.id });\n  }\n\n  private async enableParallelProcessing(event: WorkflowEvent): Promise<void> {\n    logger.info('Parallel processing enabled by coordination rule', { eventId: event.id });\n  }\n\n  private async enableDistributedProcessing(event: WorkflowEvent): Promise<void> {\n    logger.info('Distributed processing enabled by coordination rule', { eventId: event.id });\n  }\n\n  private async enableValidationGates(event: WorkflowEvent): Promise<void> {\n    logger.info('Validation gates enabled by coordination rule', { eventId: event.id });\n  }\n\n  // ==================== TRIGGER HANDLERS ====================\n\n  private async evaluateCoordinationNeed(event: WorkflowEvent): Promise<void> {\n    logger.debug('Evaluating coordination need', { eventId: event.id });\n    // Mock evaluation logic\n  }\n\n  private async aggregateResponses(event: WorkflowEvent): Promise<void> {\n    logger.debug('Aggregating responses', { eventId: event.id });\n    // Mock aggregation logic\n  }\n\n  private async createAnalysisPlan(event: WorkflowEvent): Promise<void> {\n    logger.debug('Creating analysis plan', { eventId: event.id });\n    // Mock plan creation logic\n  }\n\n  private async createEnterprisePlan(event: WorkflowEvent): Promise<void> {\n    logger.debug('Creating enterprise plan', { eventId: event.id });\n    // Mock enterprise plan creation logic\n  }\n\n  // ==================== PUBLIC API ====================\n\n  /**\n   * Register coordination strategy\n   */\n  registerStrategy(strategy: CoordinationStrategy): void {\n    this.strategies.set(strategy.name, strategy);\n    logger.info('Coordination strategy registered', { name: strategy.name });\n  }\n\n  /**\n   * Register event handler\n   */\n  registerEventHandler(eventType: string, handler: EventHandler): void {\n    if (!this.eventHandlers.has(eventType)) {\n      this.eventHandlers.set(eventType, []);\n    }\n    \n    this.eventHandlers.get(eventType)!.push(handler);\n    logger.info('Event handler registered', { eventType, handlerName: handler.name });\n  }\n\n  /**\n   * Get event queue status\n   */\n  getQueueStatus(): { length: number; isProcessing: boolean } {\n    return {\n      length: this.eventQueue.length,\n      isProcessing: this.isProcessing\n    };\n  }\n\n  /**\n   * Get registered strategies\n   */\n  getStrategies(): string[] {\n    return Array.from(this.strategies.keys());\n  }\n\n  /**\n   * Clear event queue\n   */\n  clearQueue(): void {\n    this.eventQueue = [];\n    logger.info('Event queue cleared');\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    try {\n      // Stop processing\n      if (this.processingInterval) {\n        clearInterval(this.processingInterval);\n        this.processingInterval = null;\n      }\n      \n      // Clear queues and handlers\n      this.eventQueue = [];\n      this.strategies.clear();\n      this.eventHandlers.clear();\n      \n      this.isProcessing = false;\n      \n      logger.info('WorkflowCoordinator cleanup completed');\n      \n    } catch (error) {\n      logger.error('Error during WorkflowCoordinator cleanup', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n}\n\n// ==================== INTERFACES ====================\n\ninterface EventHandler {\n  name: string;\n  execute(event: WorkflowEvent): Promise<void>;\n}"