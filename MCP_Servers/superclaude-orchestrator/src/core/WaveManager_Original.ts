import { EventEmitter } from 'eventemitter3';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '@superclaude/shared';
import {\n  WaveExecutionPlan,\n  WaveExecution,\n  WaveStatus,\n  WaveStrategy,\n  WaveExecutionError\n} from '../types/index.js';\nimport { AsyncMutex, AtomicCounter, ThreadSafeMap, AtomicBoolean } from '../utils/concurrency.js';\n\n/**\n * Manages wave-based execution for complex multi-phase operations\n * Implements compound intelligence through progressive enhancement\n */\nexport class WaveManager extends EventEmitter {\n  private activeExecutions: Map<string, WaveExecution>;\n  private executionHistory: Map<string, WaveExecution>;\n  private phaseTimeout: number = 600000; // 10 minutes per phase\n  \n  constructor() {\n    super();\n    this.activeExecutions = new Map();\n    this.executionHistory = new Map();\n  }\n\n  /**\n   * Execute wave plan\n   */\n  async executePlan(plan: WaveExecutionPlan): Promise<WaveExecution> {\n    const execution: WaveExecution = {\n      id: uuidv4(),\n      planId: plan.id,\n      status: 'planning',\n      startTime: new Date(),\n      totalTokensUsed: 0,\n      completedPhases: [],\n      failedPhases: [],\n      results: [],\n      errors: [],\n      metadata: { strategy: plan.strategy }\n    };\n    \n    try {\n      logger.info('Starting wave execution', {\n        executionId: execution.id,\n        planId: plan.id,\n        strategy: plan.strategy,\n        phaseCount: plan.phases.length\n      });\n      \n      this.activeExecutions.set(execution.id, execution);\n      \n      // Emit start event\n      this.emit('wave-started', execution);\n      \n      // Update status to executing\n      execution.status = 'executing';\n      \n      // Execute based on strategy\n      switch (plan.strategy) {\n        case 'progressive':\n          await this.executeProgressive(plan, execution);\n          break;\n        case 'systematic':\n          await this.executeSystematic(plan, execution);\n          break;\n        case 'adaptive':\n          await this.executeAdaptive(plan, execution);\n          break;\n        case 'enterprise':\n          await this.executeEnterprise(plan, execution);\n          break;\n        default:\n          throw new WaveExecutionError(\n            `Unknown wave strategy: ${plan.strategy}`,\n            execution.id\n          );\n      }\n      \n      // Complete execution\n      execution.status = 'completed';\n      execution.endTime = new Date();\n      \n      // Move to history\n      this.executionHistory.set(execution.id, execution);\n      this.activeExecutions.delete(execution.id);\n      \n      logger.info('Wave execution completed', {\n        executionId: execution.id,\n        completedPhases: execution.completedPhases.length,\n        totalTokens: execution.totalTokensUsed\n      });\n      \n      // Emit completion event\n      this.emit('wave-completed', execution);\n      \n      return execution;\n      \n    } catch (error) {\n      execution.status = 'failed';\n      execution.endTime = new Date();\n      execution.errors.push(error instanceof Error ? error.message : 'Unknown error');\n      \n      // Move to history\n      this.executionHistory.set(execution.id, execution);\n      this.activeExecutions.delete(execution.id);\n      \n      logger.error('Wave execution failed', {\n        executionId: execution.id,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      // Emit failure event\n      this.emit('wave-failed', execution, error);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Execute progressive wave strategy\n   * Incremental enhancement with iterative improvement\n   */\n  private async executeProgressive(plan: WaveExecutionPlan, execution: WaveExecution): Promise<void> {\n    logger.info('Executing progressive wave strategy', {\n      executionId: execution.id,\n      phaseCount: plan.phases.length\n    });\n    \n    // Sort phases by priority (highest first)\n    const sortedPhases = [...plan.phases].sort((a, b) => b.priority - a.priority);\n    \n    for (const phase of sortedPhases) {\n      try {\n        // Check dependencies\n        if (!this.areDependenciesMet(phase.dependencies, execution.completedPhases)) {\n          logger.warn('Phase dependencies not met, skipping', {\n            phaseId: phase.id,\n            dependencies: phase.dependencies,\n            completed: execution.completedPhases\n          });\n          continue;\n        }\n        \n        execution.currentPhase = phase.id;\n        \n        logger.info('Executing phase', {\n          executionId: execution.id,\n          phaseId: phase.id,\n          phaseName: phase.name\n        });\n        \n        // Execute phase with timeout\n        const phaseResult = await this.executePhaseWithTimeout(phase, execution);\n        \n        // Update execution state\n        execution.completedPhases.push(phase.id);\n        execution.results.push(phaseResult);\n        execution.totalTokensUsed += phase.estimatedTokens;\n        \n        // Progressive enhancement: adapt based on results\n        await this.adaptBasedOnResults(execution, phaseResult);\n        \n      } catch (error) {\n        logger.error('Phase execution failed', {\n          phaseId: phase.id,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n        \n        execution.failedPhases.push(phase.id);\n        execution.errors.push(`Phase ${phase.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        \n        // Progressive strategy: continue with other phases unless critical\n        if (phase.priority >= 9) {\n          throw new WaveExecutionError(\n            `Critical phase failed: ${phase.id}`,\n            execution.id\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute systematic wave strategy\n   * Methodical analysis with strict ordering\n   */\n  private async executeSystematic(plan: WaveExecutionPlan, execution: WaveExecution): Promise<void> {\n    logger.info('Executing systematic wave strategy', {\n      executionId: execution.id,\n      phaseCount: plan.phases.length\n    });\n    \n    // Systematic strategy requires dependency-ordered execution\n    const orderedPhases = this.orderPhasesByDependencies(plan.phases);\n    \n    for (const phase of orderedPhases) {\n      try {\n        execution.currentPhase = phase.id;\n        \n        logger.info('Executing phase systematically', {\n          executionId: execution.id,\n          phaseId: phase.id,\n          phaseName: phase.name\n        });\n        \n        // Execute phase\n        const phaseResult = await this.executePhaseWithTimeout(phase, execution);\n        \n        // Update execution state\n        execution.completedPhases.push(phase.id);\n        execution.results.push(phaseResult);\n        execution.totalTokensUsed += phase.estimatedTokens;\n        \n        // Validation if required\n        if (plan.validationRequired) {\n          await this.validatePhaseResult(phase, phaseResult, execution);\n        }\n        \n      } catch (error) {\n        // Systematic strategy: fail fast on any error\n        throw new WaveExecutionError(\n          `Systematic execution failed at phase ${phase.id}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          execution.id\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute adaptive wave strategy\n   * Dynamic configuration based on execution context\n   */\n  private async executeAdaptive(plan: WaveExecutionPlan, execution: WaveExecution): Promise<void> {\n    logger.info('Executing adaptive wave strategy', {\n      executionId: execution.id,\n      phaseCount: plan.phases.length\n    });\n    \n    let remainingPhases = [...plan.phases];\n    let concurrentPhases = Math.min(plan.maxConcurrentPhases, 2); // Start conservative\n    \n    while (remainingPhases.length > 0) {\n      // Select phases to execute concurrently\n      const executablePhases = this.selectExecutablePhases(\n        remainingPhases,\n        execution.completedPhases,\n        concurrentPhases\n      );\n      \n      if (executablePhases.length === 0) {\n        throw new WaveExecutionError(\n          'No executable phases found - possible circular dependency',\n          execution.id\n        );\n      }\n      \n      try {\n        // Execute phases concurrently\n        const phasePromises = executablePhases.map(phase => \n          this.executePhaseWithTimeout(phase, execution)\n        );\n        \n        const results = await Promise.allSettled(phasePromises);\n        \n        // Process results\n        for (let i = 0; i < results.length; i++) {\n          const result = results[i];\n          const phase = executablePhases[i];\n          \n          if (result.status === 'fulfilled') {\n            execution.completedPhases.push(phase.id);\n            execution.results.push(result.value);\n            execution.totalTokensUsed += phase.estimatedTokens;\n          } else {\n            execution.failedPhases.push(phase.id);\n            execution.errors.push(`Phase ${phase.id}: ${result.reason}`);\n          }\n        }\n        \n        // Remove completed/failed phases\n        remainingPhases = remainingPhases.filter(phase => \n          !execution.completedPhases.includes(phase.id) &&\n          !execution.failedPhases.includes(phase.id)\n        );\n        \n        // Adapt concurrency based on success rate\n        const successRate = executablePhases.length > 0 ? \n          execution.completedPhases.length / (execution.completedPhases.length + execution.failedPhases.length) : 1;\n        \n        if (successRate > 0.8 && concurrentPhases < plan.maxConcurrentPhases) {\n          concurrentPhases += 1;\n        } else if (successRate < 0.5 && concurrentPhases > 1) {\n          concurrentPhases -= 1;\n        }\n        \n      } catch (error) {\n        throw new WaveExecutionError(\n          `Adaptive execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          execution.id\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute enterprise wave strategy\n   * Large-scale orchestration with full validation\n   */\n  private async executeEnterprise(plan: WaveExecutionPlan, execution: WaveExecution): Promise<void> {\n    logger.info('Executing enterprise wave strategy', {\n      executionId: execution.id,\n      phaseCount: plan.phases.length\n    });\n    \n    // Enterprise strategy: full validation and checkpoint system\n    const checkpoints: string[] = [];\n    const orderedPhases = this.orderPhasesByDependencies(plan.phases);\n    \n    for (const phase of orderedPhases) {\n      try {\n        execution.currentPhase = phase.id;\n        \n        // Pre-execution validation\n        await this.validatePreExecution(phase, execution);\n        \n        logger.info('Executing enterprise phase', {\n          executionId: execution.id,\n          phaseId: phase.id,\n          phaseName: phase.name,\n          checkpoint: checkpoints.length\n        });\n        \n        // Execute with full monitoring\n        const phaseResult = await this.executePhaseWithTimeout(phase, execution);\n        \n        // Post-execution validation\n        await this.validatePhaseResult(phase, phaseResult, execution);\n        \n        // Update state\n        execution.completedPhases.push(phase.id);\n        execution.results.push(phaseResult);\n        execution.totalTokensUsed += phase.estimatedTokens;\n        \n        // Create checkpoint\n        checkpoints.push(phase.id);\n        await this.createCheckpoint(execution, phase.id);\n        \n        logger.info('Enterprise phase completed with checkpoint', {\n          phaseId: phase.id,\n          checkpointCount: checkpoints.length\n        });\n        \n      } catch (error) {\n        logger.error('Enterprise phase failed', {\n          phaseId: phase.id,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n        \n        // Enterprise strategy: implement rollback if configured\n        if (plan.rollbackStrategy === 'immediate') {\n          await this.rollbackToLastCheckpoint(execution, checkpoints);\n        }\n        \n        throw new WaveExecutionError(\n          `Enterprise execution failed at phase ${phase.id}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          execution.id\n        );\n      }\n    }\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  /**\n   * Execute phase with timeout\n   */\n  private async executePhaseWithTimeout(phase: any, execution: WaveExecution): Promise<Record<string, unknown>> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Phase ${phase.id} timed out after ${this.phaseTimeout}ms`));\n      }, this.phaseTimeout);\n      \n      // Mock phase execution\n      this.executePhase(phase, execution)\n        .then(result => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch(error => {\n          clearTimeout(timer);\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Execute individual phase (mock implementation)\n   */\n  private async executePhase(phase: any, execution: WaveExecution): Promise<Record<string, unknown>> {\n    // Mock implementation - would delegate to actual task execution\n    await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));\n    \n    return {\n      phaseId: phase.id,\n      phaseName: phase.name,\n      result: `Completed phase: ${phase.name}`,\n      tokensUsed: phase.estimatedTokens,\n      executionTime: 100 + Math.random() * 200,\n      timestamp: new Date()\n    };\n  }\n\n  /**\n   * Check if dependencies are met\n   */\n  private areDependenciesMet(dependencies: string[], completedPhases: string[]): boolean {\n    return dependencies.every(dep => completedPhases.includes(dep));\n  }\n\n  /**\n   * Order phases by dependencies (topological sort)\n   */\n  private orderPhasesByDependencies(phases: any[]): any[] {\n    const ordered: any[] = [];\n    const visited = new Set<string>();\n    const visiting = new Set<string>();\n    \n    const visit = (phase: any): void => {\n      if (visiting.has(phase.id)) {\n        throw new Error(`Circular dependency detected involving phase: ${phase.id}`);\n      }\n      \n      if (visited.has(phase.id)) {\n        return;\n      }\n      \n      visiting.add(phase.id);\n      \n      // Visit dependencies first\n      for (const depId of phase.dependencies) {\n        const depPhase = phases.find(p => p.id === depId);\n        if (depPhase) {\n          visit(depPhase);\n        }\n      }\n      \n      visiting.delete(phase.id);\n      visited.add(phase.id);\n      ordered.push(phase);\n    };\n    \n    for (const phase of phases) {\n      if (!visited.has(phase.id)) {\n        visit(phase);\n      }\n    }\n    \n    return ordered;\n  }\n\n  /**\n   * Select executable phases for concurrent execution\n   */\n  private selectExecutablePhases(\n    remainingPhases: any[],\n    completedPhases: string[],\n    maxCount: number\n  ): any[] {\n    return remainingPhases\n      .filter(phase => this.areDependenciesMet(phase.dependencies, completedPhases))\n      .sort((a, b) => b.priority - a.priority)\n      .slice(0, maxCount);\n  }\n\n  /**\n   * Adapt based on phase results\n   */\n  private async adaptBasedOnResults(execution: WaveExecution, result: Record<string, unknown>): Promise<void> {\n    // Mock adaptation logic\n    logger.debug('Adapting based on phase results', {\n      executionId: execution.id,\n      resultKeys: Object.keys(result)\n    });\n  }\n\n  /**\n   * Validate phase result\n   */\n  private async validatePhaseResult(\n    phase: any,\n    result: Record<string, unknown>,\n    execution: WaveExecution\n  ): Promise<void> {\n    // Mock validation logic\n    if (!result || Object.keys(result).length === 0) {\n      throw new Error(`Phase ${phase.id} produced empty result`);\n    }\n  }\n\n  /**\n   * Validate pre-execution conditions\n   */\n  private async validatePreExecution(phase: any, execution: WaveExecution): Promise<void> {\n    // Mock pre-execution validation\n    if (!this.areDependenciesMet(phase.dependencies, execution.completedPhases)) {\n      throw new Error(`Phase ${phase.id} dependencies not met`);\n    }\n  }\n\n  /**\n   * Create checkpoint\n   */\n  private async createCheckpoint(execution: WaveExecution, phaseId: string): Promise<void> {\n    // Mock checkpoint creation\n    logger.debug('Creating checkpoint', {\n      executionId: execution.id,\n      phaseId\n    });\n  }\n\n  /**\n   * Rollback to last checkpoint\n   */\n  private async rollbackToLastCheckpoint(execution: WaveExecution, checkpoints: string[]): Promise<void> {\n    // Mock rollback logic\n    logger.warn('Rolling back to last checkpoint', {\n      executionId: execution.id,\n      lastCheckpoint: checkpoints[checkpoints.length - 1]\n    });\n  }\n\n  /**\n   * Cancel execution\n   */\n  async cancelExecution(executionId: string): Promise<void> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution) {\n      throw new Error(`Execution not found: ${executionId}`);\n    }\n    \n    execution.status = 'cancelled';\n    execution.endTime = new Date();\n    \n    // Move to history\n    this.executionHistory.set(executionId, execution);\n    this.activeExecutions.delete(executionId);\n    \n    logger.info('Wave execution cancelled', { executionId });\n  }\n\n  /**\n   * Get execution history\n   */\n  getExecutionHistory(): WaveExecution[] {\n    return Array.from(this.executionHistory.values());\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    try {\n      // Cancel all active executions\n      const activeIds = Array.from(this.activeExecutions.keys());\n      await Promise.all(activeIds.map(id => this.cancelExecution(id)));\n      \n      this.activeExecutions.clear();\n      \n      logger.info('WaveManager cleanup completed');\n      \n    } catch (error) {\n      logger.error('Error during WaveManager cleanup', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n}"