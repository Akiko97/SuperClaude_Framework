import { EventEmitter } from 'eventemitter3';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '@superclaude/shared';
import {
  MultiModelRequest,
  ModelResponse,
  AIProvider,
  WaveExecutionPlan,
  WaveExecution,
  WaveStatus,
  WaveStrategy,
  WorkflowEvent,
  CoordinationStrategy,
  CircuitBreakerState,
  OrchestratorError,
  ModelProviderError,
  WaveExecutionError,
  CoordinationError
} from '../types/index.js';
import { ModelCoordinator } from './ModelCoordinator.js';
import { WaveManager } from './WaveManager.js';
import { WorkflowCoordinator } from './WorkflowCoordinator.js';
import { CircuitBreaker } from './CircuitBreaker.js';

/**
 * Core orchestration engine for SuperClaude
 * Coordinates multi-model AI interactions, wave execution, and workflow management
 */
export class OrchestratorEngine extends EventEmitter {
  private modelCoordinator: ModelCoordinator;
  private waveManager: WaveManager;
  private workflowCoordinator: WorkflowCoordinator;
  private circuitBreakers: Map<string, CircuitBreaker>;
  private activeExecutions: Map<string, WaveExecution>;
  private coordinationStrategies: Map<string, CoordinationStrategy>;
  
  constructor() {
    super();
    
    this.modelCoordinator = new ModelCoordinator();
    this.waveManager = new WaveManager();
    this.workflowCoordinator = new WorkflowCoordinator();
    this.circuitBreakers = new Map();
    this.activeExecutions = new Map();
    this.coordinationStrategies = new Map();
    
    this.setupEventHandlers();
    this.initializeDefaultStrategies();
    
    logger.setServerName('superclaude-orchestrator');
    logger.info('OrchestratorEngine initialized');\n  }\n\n  /**\n   * Setup event handlers for cross-component communication\n   */\n  private setupEventHandlers(): void {\n    // Model coordinator events\n    this.modelCoordinator.on('response-received', (response: ModelResponse) => {\n      this.handleModelResponse(response);\n    });\n    \n    this.modelCoordinator.on('provider-error', (error: ModelProviderError) => {\n      this.handleProviderError(error);\n    });\n    \n    // Wave manager events\n    this.waveManager.on('wave-started', (execution: WaveExecution) => {\n      this.activeExecutions.set(execution.id, execution);\n      this.emit('wave-started', execution);\n    });\n    \n    this.waveManager.on('wave-completed', (execution: WaveExecution) => {\n      this.activeExecutions.delete(execution.id);\n      this.emit('wave-completed', execution);\n    });\n    \n    this.waveManager.on('wave-failed', (execution: WaveExecution, error: Error) => {\n      this.activeExecutions.delete(execution.id);\n      this.emit('wave-failed', execution, error);\n    });\n    \n    // Workflow coordinator events\n    this.workflowCoordinator.on('event-processed', (event: WorkflowEvent) => {\n      this.emit('workflow-event', event);\n    });\n  }\n\n  /**\n   * Initialize default coordination strategies\n   */\n  private initializeDefaultStrategies(): void {\n    // Progressive enhancement strategy\n    const progressiveStrategy: CoordinationStrategy = {\n      name: 'progressive',\n      description: 'Progressive enhancement with iterative improvement',\n      rules: [\n        {\n          condition: 'complexity > 0.7',\n          action: 'enable-wave-mode',\n          priority: 1,\n          enabled: true\n        },\n        {\n          condition: 'token-usage > 75%',\n          action: 'enable-compression',\n          priority: 2,\n          enabled: true\n        }\n      ],\n      triggers: [\n        {\n          event: 'task-created',\n          handler: 'evaluate-coordination-need',\n          async: false\n        },\n        {\n          event: 'model-response',\n          handler: 'aggregate-responses',\n          async: true\n        }\n      ],\n      metadata: { type: 'built-in' }\n    };\n    \n    this.coordinationStrategies.set('progressive', progressiveStrategy);\n    \n    // Add other built-in strategies\n    this.addBuiltinStrategies();\n  }\n\n  /**\n   * Add built-in coordination strategies\n   */\n  private addBuiltinStrategies(): void {\n    // Systematic strategy\n    const systematicStrategy: CoordinationStrategy = {\n      name: 'systematic',\n      description: 'Systematic methodical analysis',\n      rules: [\n        {\n          condition: 'operation-type == \"analysis\"',\n          action: 'enable-deep-analysis',\n          priority: 1,\n          enabled: true\n        },\n        {\n          condition: 'file-count > 20',\n          action: 'enable-parallel-processing',\n          priority: 2,\n          enabled: true\n        }\n      ],\n      triggers: [\n        {\n          event: 'analysis-requested',\n          handler: 'create-analysis-plan',\n          async: false\n        }\n      ],\n      metadata: { type: 'built-in' }\n    };\n    \n    this.coordinationStrategies.set('systematic', systematicStrategy);\n    \n    // Enterprise strategy\n    const enterpriseStrategy: CoordinationStrategy = {\n      name: 'enterprise',\n      description: 'Enterprise-scale orchestration',\n      rules: [\n        {\n          condition: 'file-count > 100',\n          action: 'enable-distributed-processing',\n          priority: 1,\n          enabled: true\n        },\n        {\n          condition: 'complexity > 0.8',\n          action: 'enable-validation-gates',\n          priority: 2,\n          enabled: true\n        }\n      ],\n      triggers: [\n        {\n          event: 'large-scale-operation',\n          handler: 'create-enterprise-plan',\n          async: false\n        }\n      ],\n      metadata: { type: 'built-in' }\n    };\n    \n    this.coordinationStrategies.set('enterprise', enterpriseStrategy);\n  }\n\n  // ==================== PUBLIC API ====================\n\n  /**\n   * Execute multi-model request\n   */\n  async executeMultiModelRequest(request: MultiModelRequest): Promise<ModelResponse[]> {\n    try {\n      logger.info('Executing multi-model request', { \n        requestId: request.id,\n        providers: request.preferredProviders,\n        capabilities: request.requiredCapabilities\n      });\n      \n      // Check circuit breakers\n      await this.checkCircuitBreakers(request.preferredProviders || []);\n      \n      // Execute request through model coordinator\n      const responses = await this.modelCoordinator.executeRequest(request);\n      \n      // Process and validate responses\n      const validatedResponses = await this.validateResponses(responses);\n      \n      logger.info('Multi-model request completed', {\n        requestId: request.id,\n        responseCount: validatedResponses.length\n      });\n      \n      return validatedResponses;\n      \n    } catch (error) {\n      logger.error('Multi-model request failed', {\n        requestId: request.id,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw new OrchestratorError(\n        `Multi-model request failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        'MULTI_MODEL_REQUEST_FAILED',\n        { requestId: request.id }\n      );\n    }\n  }\n\n  /**\n   * Create and execute wave plan\n   */\n  async executeWave(plan: WaveExecutionPlan): Promise<WaveExecution> {\n    try {\n      logger.info('Starting wave execution', {\n        planId: plan.id,\n        strategy: plan.strategy,\n        phaseCount: plan.phases.length\n      });\n      \n      // Validate plan\n      await this.validateWavePlan(plan);\n      \n      // Execute through wave manager\n      const execution = await this.waveManager.executePlan(plan);\n      \n      logger.info('Wave execution completed', {\n        executionId: execution.id,\n        status: execution.status\n      });\n      \n      return execution;\n      \n    } catch (error) {\n      logger.error('Wave execution failed', {\n        planId: plan.id,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw new WaveExecutionError(\n        `Wave execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        plan.id,\n        { planId: plan.id }\n      );\n    }\n  }\n\n  /**\n   * Emit workflow event\n   */\n  async emitWorkflowEvent(event: WorkflowEvent): Promise<void> {\n    try {\n      await this.workflowCoordinator.processEvent(event);\n    } catch (error) {\n      logger.error('Workflow event processing failed', {\n        eventId: event.id,\n        eventType: event.type,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw new CoordinationError(\n        `Workflow event processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        { eventId: event.id }\n      );\n    }\n  }\n\n  /**\n   * Register coordination strategy\n   */\n  registerCoordinationStrategy(strategy: CoordinationStrategy): void {\n    this.coordinationStrategies.set(strategy.name, strategy);\n    logger.info('Coordination strategy registered', { name: strategy.name });\n  }\n\n  /**\n   * Get active executions\n   */\n  getActiveExecutions(): WaveExecution[] {\n    return Array.from(this.activeExecutions.values());\n  }\n\n  /**\n   * Get execution status\n   */\n  getExecutionStatus(executionId: string): WaveExecution | undefined {\n    return this.activeExecutions.get(executionId);\n  }\n\n  /**\n   * Cancel execution\n   */\n  async cancelExecution(executionId: string): Promise<boolean> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution) {\n      return false;\n    }\n    \n    try {\n      await this.waveManager.cancelExecution(executionId);\n      this.activeExecutions.delete(executionId);\n      \n      logger.info('Execution cancelled', { executionId });\n      return true;\n      \n    } catch (error) {\n      logger.error('Failed to cancel execution', {\n        executionId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return false;\n    }\n  }\n\n  // ==================== PRIVATE METHODS ====================\n\n  /**\n   * Check circuit breakers for providers\n   */\n  private async checkCircuitBreakers(providers: AIProvider[]): Promise<void> {\n    for (const provider of providers) {\n      const breaker = this.circuitBreakers.get(provider);\n      if (breaker && breaker.getState() === 'open') {\n        throw new ModelProviderError(\n          `Circuit breaker is open for provider: ${provider}`,\n          provider,\n          { state: breaker.getState() }\n        );\n      }\n    }\n  }\n\n  /**\n   * Validate model responses\n   */\n  private async validateResponses(responses: ModelResponse[]): Promise<ModelResponse[]> {\n    return responses.filter(response => {\n      // Basic validation\n      if (!response.response || response.confidence < 0.1) {\n        logger.warn('Invalid response filtered out', {\n          provider: response.provider,\n          confidence: response.confidence\n        });\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Validate wave execution plan\n   */\n  private async validateWavePlan(plan: WaveExecutionPlan): Promise<void> {\n    if (plan.phases.length === 0) {\n      throw new WaveExecutionError('Wave plan must have at least one phase', plan.id);\n    }\n    \n    // Check for circular dependencies\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    \n    for (const phase of plan.phases) {\n      if (!visited.has(phase.id)) {\n        if (this.hasCyclicDependency(phase.id, plan.phases, visited, recursionStack)) {\n          throw new WaveExecutionError('Circular dependency detected in wave plan', plan.id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check for cyclic dependencies in wave plan\n   */\n  private hasCyclicDependency(\n    phaseId: string,\n    phases: any[],\n    visited: Set<string>,\n    recursionStack: Set<string>\n  ): boolean {\n    visited.add(phaseId);\n    recursionStack.add(phaseId);\n    \n    const phase = phases.find(p => p.id === phaseId);\n    if (!phase) return false;\n    \n    for (const depId of phase.dependencies) {\n      if (!visited.has(depId)) {\n        if (this.hasCyclicDependency(depId, phases, visited, recursionStack)) {\n          return true;\n        }\n      } else if (recursionStack.has(depId)) {\n        return true;\n      }\n    }\n    \n    recursionStack.delete(phaseId);\n    return false;\n  }\n\n  /**\n   * Handle model response\n   */\n  private async handleModelResponse(response: ModelResponse): Promise<void> {\n    logger.debug('Processing model response', {\n      provider: response.provider,\n      requestId: response.requestId,\n      confidence: response.confidence\n    });\n    \n    // Update circuit breaker\n    const breaker = this.getOrCreateCircuitBreaker(response.provider);\n    breaker.recordSuccess();\n    \n    // Emit event for workflow coordination\n    const event: WorkflowEvent = {\n      id: uuidv4(),\n      type: 'model-response',\n      source: 'model-coordinator',\n      payload: { response },\n      timestamp: new Date(),\n      priority: 5\n    };\n    \n    await this.emitWorkflowEvent(event);\n  }\n\n  /**\n   * Handle provider error\n   */\n  private async handleProviderError(error: ModelProviderError): Promise<void> {\n    logger.error('Provider error occurred', {\n      provider: error.provider,\n      message: error.message\n    });\n    \n    // Update circuit breaker\n    const breaker = this.getOrCreateCircuitBreaker(error.provider);\n    breaker.recordFailure();\n  }\n\n  /**\n   * Get or create circuit breaker for provider\n   */\n  private getOrCreateCircuitBreaker(provider: AIProvider): CircuitBreaker {\n    let breaker = this.circuitBreakers.get(provider);\n    if (!breaker) {\n      breaker = new CircuitBreaker({\n        failureThreshold: 5,\n        timeoutMs: 60000,\n        resetTimeoutMs: 300000\n      });\n      this.circuitBreakers.set(provider, breaker);\n    }\n    return breaker;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    try {\n      // Cancel all active executions\n      const activeIds = Array.from(this.activeExecutions.keys());\n      await Promise.all(activeIds.map(id => this.cancelExecution(id)));\n      \n      // Cleanup components\n      await this.modelCoordinator.cleanup();\n      await this.waveManager.cleanup();\n      await this.workflowCoordinator.cleanup();\n      \n      // Clear circuit breakers\n      this.circuitBreakers.clear();\n      \n      logger.info('OrchestratorEngine cleanup completed');\n      \n    } catch (error) {\n      logger.error('Error during cleanup', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n}"